{"version":3,"file":"lit-html.js","sourceRoot":"","sources":["src/lit-html.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * TypeScript has a problem with precompiling templates literals\n * https://github.com/Microsoft/TypeScript/issues/17956\n *\n * TODO(justinfagnani): Run tests compiled to ES5 with both Babel and\n * TypeScript to verify correctness.\n */\nconst envCachesTemplates =\n    ((t: any) => t() === t())(() => ((s: TemplateStringsArray) => s) ``);\n\n// The first argument to JS template tags retain identity across multiple\n// calls to a tag for the same literal, so we can cache work done per literal\n// in a Map.\nconst templates = new Map<TemplateStringsArray|string, Template>();\nconst svgTemplates = new Map<TemplateStringsArray|string, Template>();\n\n/**\n * Interprets a template literal as an HTML template that can efficiently\n * render to and update a container.\n */\nexport const html = (strings: TemplateStringsArray, ...values: any[]) =>\n    litTag(strings, values, templates, false);\n\n/**\n * Interprets a template literal as an SVG template that can efficiently\n * render to and update a container.\n */\nexport const svg = (strings: TemplateStringsArray, ...values: any[]) =>\n    litTag(strings, values, svgTemplates, true);\n\nfunction litTag(\n    strings: TemplateStringsArray,\n    values: any[],\n    templates: Map<TemplateStringsArray|string, Template>,\n    isSvg: boolean): TemplateResult {\n  const key = envCachesTemplates ?\n      strings :\n      strings.join('{{--uniqueness-workaround--}}');\n  let template = templates.get(key);\n  if (template === undefined) {\n    template = new Template(strings, isSvg);\n    templates.set(key, template);\n  }\n  return new TemplateResult(template, values);\n}\n\n/**\n * The return type of `html`, which holds a Template and the values from\n * interpolated expressions.\n */\nexport class TemplateResult {\n  template: Template;\n  values: any[];\n\n  constructor(template: Template, values: any[]) {\n    this.template = template;\n    this.values = values;\n  }\n}\n\n/**\n * Renders a template to a container.\n *\n * To update a container with new values, reevaluate the template literal and\n * call `render` with the new result.\n */\nexport function render(\n    result: TemplateResult,\n    container: Element|DocumentFragment,\n    partCallback: PartCallback = defaultPartCallback) {\n  let instance = (container as any).__templateInstance as any;\n\n  // Repeat render, just call update()\n  if (instance !== undefined && instance.template === result.template &&\n      instance._partCallback === partCallback) {\n    instance.update(result.values);\n    return;\n  }\n\n  // First render, create a new TemplateInstance and append it\n  instance = new TemplateInstance(result.template, partCallback);\n  (container as any).__templateInstance = instance;\n\n  const fragment = instance._clone();\n  instance.update(result.values);\n\n  removeNodes(container, container.firstChild);\n  container.appendChild(fragment);\n}\n\n/**\n * An expression marker with embedded unique key to avoid\n * https://github.com/PolymerLabs/lit-html/issues/62\n */\nconst marker = `{{lit-${String(Math.random()).slice(2)}}}`;\nconst nodeMarker = `<!--${marker}-->`;\nconst markerRegex = new RegExp(`${marker}|${nodeMarker}`);\n\n/**\n * This regex extracts the attribute name preceding an attribute-position\n * expression. It does this by matching the syntax allowed for attributes\n * against the string literal directly preceding the expression, assuming that\n * the expression is in an attribute-value position.\n *\n * See attributes in the HTML spec:\n * https://www.w3.org/TR/html5/syntax.html#attributes-0\n *\n * \"\\0-\\x1F\\x7F-\\x9F\" are Unicode control characters\n *\n * \" \\x09\\x0a\\x0c\\x0d\" are HTML space characters:\n * https://www.w3.org/TR/html5/infrastructure.html#space-character\n *\n * So an attribute is:\n *  * The name: any character except a control character, space character, ('),\n *    (\"), \">\", \"=\", or \"/\"\n *  * Followed by zero or more space characters\n *  * Followed by \"=\"\n *  * Followed by zero or more space characters\n *  * Followed by:\n *    * Any character except space, ('), (\"), \"<\", \">\", \"=\", (`), or\n *    * (\") then any non-(\"), or\n *    * (') then any non-(')\n */\nconst lastAttributeNameRegex =\n    /[ \\x09\\x0a\\x0c\\x0d]([^\\0-\\x1F\\x7F-\\x9F \\x09\\x0a\\x0c\\x0d\"'>=/]+)[ \\x09\\x0a\\x0c\\x0d]*=[ \\x09\\x0a\\x0c\\x0d]*(?:[^ \\x09\\x0a\\x0c\\x0d\"'`<>=]*|\"[^\"]*|'[^']*)$/;\n\n/**\n * Finds the closing index of the last closed HTML tag.\n * This has 3 possible return values:\n *   - `-1`, meaning there is no tag in str.\n *   - `string.length`, meaning the last opened tag is unclosed.\n *   - Some positive number < str.length, meaning the index of the closing '>'.\n */\nfunction findTagClose(str: string): number {\n  const close = str.lastIndexOf('>');\n  const open = str.indexOf('<', close + 1);\n  return open > -1 ? str.length : close;\n}\n\n/**\n * A placeholder for a dynamic expression in an HTML template.\n *\n * There are two built-in part types: AttributePart and NodePart. NodeParts\n * always represent a single dynamic expression, while AttributeParts may\n * represent as many expressions are contained in the attribute.\n *\n * A Template's parts are mutable, so parts can be replaced or modified\n * (possibly to implement different template semantics). The contract is that\n * parts can only be replaced, not removed, added or reordered, and parts must\n * always consume the correct number of values in their `update()` method.\n *\n * TODO(justinfagnani): That requirement is a little fragile. A\n * TemplateInstance could instead be more careful about which values it gives\n * to Part.update().\n */\nexport class TemplatePart {\n  constructor(\n      public type: string, public index: number, public name?: string,\n      public rawName?: string, public strings?: string[]) {\n  }\n}\n\n\nexport class Template {\n  parts: TemplatePart[] = [];\n  element: HTMLTemplateElement;\n\n  constructor(strings: TemplateStringsArray, svg: boolean = false) {\n    const element = this.element = document.createElement('template');\n    element.innerHTML = this._getHtml(strings, svg);\n    const content = element.content;\n\n    if (svg) {\n      const svgElement = content.firstChild!;\n      content.removeChild(svgElement);\n      reparentNodes(content, svgElement.firstChild);\n    }\n\n    // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null\n    const walker = document.createTreeWalker(\n        content,\n        133 /* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT |\n               NodeFilter.SHOW_TEXT */\n        ,\n        null as any,\n        false);\n    let index = -1;\n    let partIndex = 0;\n    const nodesToRemove: Node[] = [];\n\n    // The actual previous node, accounting for removals: if a node is removed\n    // it will never be the previousNode.\n    let previousNode: Node|undefined;\n    // Used to set previousNode at the top of the loop.\n    let currentNode: Node|undefined;\n\n    while (walker.nextNode()) {\n      index++;\n      previousNode = currentNode;\n      const node = currentNode = walker.currentNode as Element;\n      if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {\n        if (!node.hasAttributes()) {\n          continue;\n        }\n        const attributes = node.attributes;\n        // Per https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap,\n        // attributes are not guaranteed to be returned in document order. In\n        // particular, Edge/IE can return them out of order, so we cannot assume\n        // a correspondance between part index and attribute index.\n        let count = 0;\n        for (let i = 0; i < attributes.length; i++) {\n          if (attributes[i].value.indexOf(marker) >= 0) {\n            count++;\n          }\n        }\n        while (count-- > 0) {\n          // Get the template literal section leading up to the first\n          // expression in this attribute attribute\n          const stringForPart = strings[partIndex];\n          // Find the attribute name\n          const attributeNameInPart =\n              lastAttributeNameRegex.exec(stringForPart)![1];\n          // Find the corresponding attribute\n          const attribute = attributes.getNamedItem(attributeNameInPart);\n          const stringsForAttributeValue = attribute.value.split(markerRegex);\n          this.parts.push(new TemplatePart(\n              'attribute',\n              index,\n              attribute.name,\n              attributeNameInPart,\n              stringsForAttributeValue));\n          node.removeAttribute(attribute.name);\n          partIndex += stringsForAttributeValue.length - 1;\n        }\n      } else if (node.nodeType === 3 /* Node.TEXT_NODE */) {\n        const nodeValue = node.nodeValue!;\n        if (nodeValue.indexOf(marker) < 0) {\n          continue;\n        }\n\n        const parent = node.parentNode!;\n        const strings = nodeValue.split(markerRegex);\n        const lastIndex = strings.length - 1;\n\n        // We have a part for each match found\n        partIndex += lastIndex;\n\n        // We keep this current node, but reset its content to the last\n        // literal part. We insert new literal nodes before this so that the\n        // tree walker keeps its position correctly.\n        node.textContent = strings[lastIndex];\n\n        // Generate a new text node for each literal section\n        // These nodes are also used as the markers for node parts\n        for (let i = 0; i < lastIndex; i++) {\n          parent.insertBefore(document.createTextNode(strings[i]), node);\n          this.parts.push(new TemplatePart('node', index++));\n        }\n      } else if (\n          node.nodeType === 8 /* Node.COMMENT_NODE */ &&\n          node.nodeValue === marker) {\n        const parent = node.parentNode!;\n        // Add a new marker node to be the startNode of the Part if any of the\n        // following are true:\n        //  * We don't have a previousSibling\n        //  * previousSibling is being removed (thus it's not the\n        //    `previousNode`)\n        //  * previousSibling is not a Text node\n        //\n        // TODO(justinfagnani): We should be able to use the previousNode here\n        // as the marker node and reduce the number of extra nodes we add to a\n        // template. See https://github.com/PolymerLabs/lit-html/issues/147\n        const previousSibling = node.previousSibling;\n        if (previousSibling === null || previousSibling !== previousNode ||\n            previousSibling.nodeType !== Node.TEXT_NODE) {\n          parent.insertBefore(document.createTextNode(''), node);\n        } else {\n          index--;\n        }\n        this.parts.push(new TemplatePart('node', index++));\n        nodesToRemove.push(node);\n        // If we don't have a nextSibling add a marker node.\n        // We don't have to check if the next node is going to be removed,\n        // because that node will induce a new marker if so.\n        if (node.nextSibling === null) {\n          parent.insertBefore(document.createTextNode(''), node);\n        } else {\n          index--;\n        }\n        currentNode = previousNode;\n        partIndex++;\n      }\n    }\n\n    // Remove text binding nodes after the walk to not disturb the TreeWalker\n    for (const n of nodesToRemove) {\n      n.parentNode!.removeChild(n);\n    }\n  }\n\n  /**\n   * Returns a string of HTML used to create a <template> element.\n   */\n  private _getHtml(strings: TemplateStringsArray, svg?: boolean): string {\n    const l = strings.length - 1;\n    let html = '';\n    let isTextBinding = true;\n    for (let i = 0; i < l; i++) {\n      const s = strings[i];\n      html += s;\n      // We're in a text position if the previous string closed its tags.\n      // If it doesn't have any tags, then we use the previous text position\n      // state.\n      const closing = findTagClose(s);\n      isTextBinding = closing > -1 ? closing < s.length : isTextBinding;\n      html += isTextBinding ? nodeMarker : marker;\n    }\n    html += strings[l];\n    return svg ? `<svg>${html}</svg>` : html;\n  }\n}\n\n/**\n * Returns a value ready to be inserted into a Part from a user-provided value.\n *\n * If the user value is a directive, this invokes the directive with the given\n * part. If the value is null, it's converted to undefined to work better\n * with certain DOM APIs, like textContent.\n */\nexport const getValue = (part: Part, value: any) => {\n  // `null` as the value of a Text node will render the string 'null'\n  // so we convert it to undefined\n  if (isDirective(value)) {\n    value = value(part);\n    return directiveValue;\n  }\n  return value === null ? undefined : value;\n};\n\nexport type DirectiveFn<P extends Part = Part> = (part: P) => any;\n\nexport const directive = <P extends Part = Part, F = DirectiveFn<P>>(f: F): F => {\n  (f as any).__litDirective = true;\n  return f;\n};\n\nconst isDirective = (o: any) =>\n    typeof o === 'function' && o.__litDirective === true;\n\nconst directiveValue = {};\n\nexport interface Part {\n  instance: TemplateInstance;\n  size?: number;\n}\n\nexport interface SinglePart extends Part { setValue(value: any): void; }\n\nexport interface MultiPart extends Part {\n  setValue(values: any[], startIndex: number): void;\n}\n\nexport class AttributePart implements MultiPart {\n  instance: TemplateInstance;\n  element: Element;\n  name: string;\n  strings: string[];\n  size: number;\n\n  constructor(\n      instance: TemplateInstance, element: Element, name: string,\n      strings: string[]) {\n    this.instance = instance;\n    this.element = element;\n    this.name = name;\n    this.strings = strings;\n    this.size = strings.length - 1;\n  }\n\n  protected _interpolate(values: any[], startIndex: number) {\n    const strings = this.strings;\n    const l = strings.length - 1;\n    let text = '';\n\n    for (let i = 0; i < l; i++) {\n      text += strings[i];\n      const v = getValue(this, values[startIndex + i]);\n      if (v && v !== directiveValue &&\n          (Array.isArray(v) || typeof v !== 'string' && v[Symbol.iterator])) {\n        for (const t of v) {\n          // TODO: we need to recursively call getValue into iterables...\n          text += t;\n        }\n      } else {\n        text += v;\n      }\n    }\n    return text + strings[l];\n  }\n\n  setValue(values: any[], startIndex: number): void {\n    const text = this._interpolate(values, startIndex);\n    this.element.setAttribute(this.name, text);\n  }\n}\n\nexport class NodePart implements SinglePart {\n  instance: TemplateInstance;\n  startNode: Node;\n  endNode: Node;\n  _previousValue: any;\n\n  constructor(instance: TemplateInstance, startNode: Node, endNode: Node) {\n    this.instance = instance;\n    this.startNode = startNode;\n    this.endNode = endNode;\n    this._previousValue = undefined;\n  }\n\n  setValue(value: any): void {\n    value = getValue(this, value);\n    if (value === directiveValue) {\n      return;\n    }\n    if (value === null ||\n        !(typeof value === 'object' || typeof value === 'function')) {\n      // Handle primitive values\n      // If the value didn't change, do nothing\n      if (value === this._previousValue) {\n        return;\n      }\n      this._setText(value);\n    } else if (value instanceof TemplateResult) {\n      this._setTemplateResult(value);\n    } else if (Array.isArray(value) || value[Symbol.iterator]) {\n      this._setIterable(value);\n    } else if (value instanceof Node) {\n      this._setNode(value);\n    } else if (value.then !== undefined) {\n      this._setPromise(value);\n    } else {\n      // Fallback, will render the string representation\n      this._setText(value);\n    }\n  }\n\n  private _insert(node: Node) {\n    this.endNode.parentNode!.insertBefore(node, this.endNode);\n  }\n\n  private _setNode(value: Node): void {\n    if (this._previousValue === value) {\n      return;\n    }\n    this.clear();\n    this._insert(value);\n    this._previousValue = value;\n  }\n\n  private _setText(value: string): void {\n    const node = this.startNode.nextSibling!;\n    value = value === undefined ? '' : value;\n    if (node === this.endNode.previousSibling &&\n        node.nodeType === Node.TEXT_NODE) {\n      // If we only have a single text node between the markers, we can just\n      // set its value, rather than replacing it.\n      // TODO(justinfagnani): Can we just check if _previousValue is\n      // primitive?\n      node.textContent = value;\n    } else {\n      this._setNode(document.createTextNode(value));\n    }\n    this._previousValue = value;\n  }\n\n  private _setTemplateResult(value: TemplateResult): void {\n    let instance: TemplateInstance;\n    if (this._previousValue &&\n        this._previousValue.template === value.template) {\n      instance = this._previousValue;\n    } else {\n      instance =\n          new TemplateInstance(value.template, this.instance._partCallback);\n      this._setNode(instance._clone());\n      this._previousValue = instance;\n    }\n    instance.update(value.values);\n  }\n\n  private _setIterable(value: any): void {\n    // For an Iterable, we create a new InstancePart per item, then set its\n    // value to the item. This is a little bit of overhead for every item in\n    // an Iterable, but it lets us recurse easily and efficiently update Arrays\n    // of TemplateResults that will be commonly returned from expressions like:\n    // array.map((i) => html`${i}`), by reusing existing TemplateInstances.\n\n    // If _previousValue is an array, then the previous render was of an\n    // iterable and _previousValue will contain the NodeParts from the previous\n    // render. If _previousValue is not an array, clear this part and make a new\n    // array for NodeParts.\n    if (!Array.isArray(this._previousValue)) {\n      this.clear();\n      this._previousValue = [];\n    }\n\n    // Lets us keep track of how many items we stamped so we can clear leftover\n    // items from a previous render\n    const itemParts = this._previousValue as any[];\n    let partIndex = 0;\n\n    for (const item of value) {\n      // Try to reuse an existing part\n      let itemPart = itemParts[partIndex];\n\n      // If no existing part, create a new one\n      if (itemPart === undefined) {\n        // If we're creating the first item part, it's startNode should be the\n        // container's startNode\n        let itemStart = this.startNode;\n\n        // If we're not creating the first part, create a new separator marker\n        // node, and fix up the previous part's endNode to point to it\n        if (partIndex > 0) {\n          const previousPart = itemParts[partIndex - 1];\n          itemStart = previousPart.endNode = document.createTextNode('');\n          this._insert(itemStart);\n        }\n        itemPart = new NodePart(this.instance, itemStart, this.endNode);\n        itemParts.push(itemPart);\n      }\n      itemPart.setValue(item);\n      partIndex++;\n    }\n\n    if (partIndex === 0) {\n      this.clear();\n      this._previousValue = undefined;\n    } else if (partIndex < itemParts.length) {\n      const lastPart = itemParts[partIndex - 1];\n      // Truncate the parts array so _previousValue reflects the current state\n      itemParts.length = partIndex;\n      this.clear(lastPart.endNode.previousSibling!);\n      lastPart.endNode = this.endNode;\n    }\n  }\n\n  private _setPromise(value: Promise<any>): void {\n    this._previousValue = value;\n    value.then((v: any) => {\n      if (this._previousValue === value) {\n        this.setValue(v);\n      }\n    });\n  }\n\n  clear(startNode: Node = this.startNode) {\n    removeNodes(\n        this.startNode.parentNode!, startNode.nextSibling!, this.endNode);\n  }\n}\n\nexport type PartCallback =\n    (instance: TemplateInstance, templatePart: TemplatePart, node: Node) =>\n        Part;\n\nexport const defaultPartCallback =\n    (instance: TemplateInstance,\n     templatePart: TemplatePart,\n     node: Node): Part => {\n      if (templatePart.type === 'attribute') {\n        return new AttributePart(\n            instance, node as Element, templatePart.name!, templatePart.strings!\n        );\n      } else if (templatePart.type === 'node') {\n        return new NodePart(instance, node, node.nextSibling!);\n      }\n      throw new Error(`Unknown part type ${templatePart.type}`);\n    };\n\n/**\n * An instance of a `Template` that can be attached to the DOM and updated\n * with new values.\n */\nexport class TemplateInstance {\n  _parts: Part[] = [];\n  _partCallback: PartCallback;\n  template: Template;\n\n  constructor(\n      template: Template, partCallback: PartCallback = defaultPartCallback) {\n    this.template = template;\n    this._partCallback = partCallback;\n  }\n\n  update(values: any[]) {\n    let valueIndex = 0;\n    for (const part of this._parts) {\n      if (part.size === undefined) {\n        (part as SinglePart).setValue(values[valueIndex]);\n        valueIndex++;\n      } else {\n        (part as MultiPart).setValue(values, valueIndex);\n        valueIndex += part.size;\n      }\n    }\n  }\n\n  _clone(): DocumentFragment {\n    const fragment = document.importNode(this.template.element.content, true);\n    const parts = this.template.parts;\n\n    if (parts.length > 0) {\n      // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be\n      // null\n      const walker = document.createTreeWalker(\n          fragment,\n          133 /* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT |\n                 NodeFilter.SHOW_TEXT */\n          ,\n          null as any,\n          false);\n\n      let index = -1;\n      for (let i = 0; i < parts.length; i++) {\n        const part = parts[i];\n        while (index < part.index) {\n          index++;\n          walker.nextNode();\n        }\n        this._parts.push(this._partCallback(this, part, walker.currentNode));\n      }\n    }\n    return fragment;\n  }\n}\n\n/**\n * Reparents nodes, starting from `startNode` (inclusive) to `endNode`\n * (exclusive), into another container (could be the same container), before\n * `beforeNode`. If `beforeNode` is null, it appends the nodes to the\n * container.\n */\nexport const reparentNodes =\n    (container: Node,\n     start: Node | null,\n     end: Node | null = null,\n     before: Node | null = null): void => {\n      let node = start;\n      while (node !== end) {\n        const n = node!.nextSibling;\n        container.insertBefore(node!, before as Node);\n        node = n;\n      }\n    };\n\n/**\n * Removes nodes, starting from `startNode` (inclusive) to `endNode`\n * (exclusive), from `container`.\n */\nexport const removeNodes =\n    (container: Node, startNode: Node | null, endNode: Node | null = null):\n        void => {\n          let node = startNode;\n          while (node !== endNode) {\n            const n = node!.nextSibling;\n            container.removeChild(node!);\n            node = n;\n          }\n        };\n"]}